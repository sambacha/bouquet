{"version":3,"file":"ethereumTypes.js","sourceRoot":"","sources":["../../ts/types/ethereumTypes.ts"],"names":[],"mappings":"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","sourcesContent":["import * as t from 'funtypes'\n\nconst BigIntParser: t.ParsedValue<t.String, bigint>['config'] = {\n\tparse: (value) => {\n\t\tif (!/^0x([a-fA-F0-9]{1,64})$/.test(value))\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `${value} is not a hex string encoded number.`,\n\t\t\t}\n\t\telse return { success: true, value: BigInt(value) }\n\t},\n\tserialize: (value) => {\n\t\tif (typeof value !== 'bigint') return { success: false, message: `${typeof value} is not a bigint.` }\n\t\treturn { success: true, value: `0x${value.toString(16)}` }\n\t},\n}\n\nexport const AddressParser: t.ParsedValue<t.String, bigint>['config'] = {\n\tparse: (value) => {\n\t\tif (!/^0x([a-fA-F0-9]{40})$/.test(value))\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `${value} is not a hex string encoded address.`,\n\t\t\t}\n\t\telse return { success: true, value: BigInt(value) }\n\t},\n\tserialize: (value) => {\n\t\tif (typeof value !== 'bigint') return { success: false, message: `${typeof value} is not a bigint.` }\n\t\treturn { success: true, value: `0x${value.toString(16).padStart(40, '0')}` }\n\t},\n}\n\nconst Bytes32Parser: t.ParsedValue<t.String, bigint>['config'] = {\n\tparse: (value) => {\n\t\tif (!/^0x([a-fA-F0-9]{64})$/.test(value))\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `${value} is not a hex string encoded 32 byte value.`,\n\t\t\t}\n\t\telse return { success: true, value: BigInt(value) }\n\t},\n\tserialize: (value) => {\n\t\tif (typeof value !== 'bigint') return { success: false, message: `${typeof value} is not a bigint.` }\n\t\treturn { success: true, value: `0x${value.toString(16).padStart(64, '0')}` }\n\t},\n}\n\nexport const BytesParser: t.ParsedValue<t.String, Uint8Array>['config'] = {\n\tparse: (value) => {\n\t\tconst match = /^(?:0x)?([a-fA-F0-9]*)$/.exec(value)\n\t\tif (match === null)\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Expected a hex string encoded byte array with an optional '0x' prefix but received ${value}`,\n\t\t\t}\n\t\tconst normalized = match[1]\n\t\tif (normalized.length % 2)\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tmessage: `Hex string encoded byte array must be an even number of charcaters long.`,\n\t\t\t}\n\t\tconst bytes = new Uint8Array(normalized.length / 2)\n\t\tfor (let i = 0; i < normalized.length; i += 2) {\n\t\t\tbytes[i / 2] = Number.parseInt(`${normalized[i]}${normalized[i + 1]}`, 16)\n\t\t}\n\t\treturn { success: true, value: new Uint8Array(bytes) }\n\t},\n\tserialize: (value) => {\n\t\tif (!(value instanceof Uint8Array)) return { success: false, message: `${typeof value} is not a Uint8Array.` }\n\t\tlet result = ''\n\t\tfor (let i = 0; i < value.length; ++i) {\n\t\t\tresult += ('0' + value[i].toString(16)).slice(-2)\n\t\t}\n\t\treturn { success: true, value: `0x${result}` }\n\t},\n}\n\nconst OptionalBytesParser: t.ParsedValue<t.Union<[t.String, t.Literal<undefined>]>, Uint8Array>['config'] = {\n\tparse: (value) => BytesParser.parse(value || '0x'),\n\tserialize: (value) => BytesParser.serialize!(value || new Uint8Array()),\n}\n\nexport const LiteralConverterParserFactory: <TInput, TOutput>(input: TInput, output: TOutput) => t.ParsedValue<t.Runtype<TInput>, TOutput>['config'] = (\n\tinput,\n\toutput,\n) => {\n\treturn {\n\t\tparse: (value) => (value === input ? { success: true, value: output } : { success: false, message: `${value} was expected to be literal.` }),\n\t\tserialize: (value) => (value === output ? { success: true, value: input } : { success: false, message: `${value} was expected to be literal.` }),\n\t}\n}\n\nexport const EthereumQuantity = t.String.withParser(BigIntParser)\nexport type EthereumQuantity = t.Static<typeof EthereumQuantity>\n\nexport const EthereumData = t.String.withParser(BytesParser)\nexport type EthereumData = t.Static<typeof EthereumData>\n\nexport const EthereumAddress = t.String.withParser(AddressParser)\nexport type EthereumAddress = t.Static<typeof EthereumAddress>\n\nexport const EthereumBytes32 = t.String.withParser(Bytes32Parser)\nexport type EthereumBytes32 = t.Static<typeof EthereumBytes32>\n\nexport const EthereumInput = t.Union(t.String, t.Undefined).withParser(OptionalBytesParser)\nexport type EthereumInput = t.Static<typeof EthereumInput>\n\n"]}